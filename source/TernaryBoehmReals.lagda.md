```agda
{-# OPTIONS --without-K --exact-split #-}

open import SpartanMLTT hiding (decidable)
open import Two-Properties hiding (zero-is-not-one)
open import NaturalsOrder
open import NaturalsAddition renaming (_+_ to _+â„•_)
open import IntegersB
-- open import IntegersOrder
open import IntegersAddition renaming (_+_ to _+â„¤_)
open import IntegersNegation renaming (-_  to  âˆ’â„¤_)
open import UF-Subsingletons

module TernaryBoehmReals
 (fe : {ğ“¤ ğ“¥ : Universe} â†’ {X : ğ“¤ Ì‡ } {Y : X â†’ ğ“¥ Ì‡ } {f g : Î  Y}
                        â†’ f âˆ¼ g â†’ f â‰¡ g) where

open import InfiniteSearch2 fe

{-# BUILTIN INTEGER       â„¤       #-}
{-# BUILTIN INTEGERPOS    pos     #-}
{-# BUILTIN INTEGERNEGSUC negsucc #-}
```

##

We encode real numbers using the data type for ternary Boehm reals ğ•‚.

Each ğ•‚ is a function x ê‰ â„¤ â†’ â„¤ with some restrictions on it, so that
we only have our encodings of real numbers inside ğ•‚, and not any
function of type â„¤ â†’ â„¤.

The function x : â„¤ â†’ â„¤ takes a "precision-level" n : â„¤ and gives back
an encoding x(n) : â„¤ of a real interval.

##

The idea is that each precision-level n : â„¤ represents a "layer" in
the following illustrative "brick pattern".

Level n+1 has bricks half the size of those on level n.
Here level 0 and 1 are shown.

-1        0         1         2
__________ _________ _________ ____
|___-2____|____0____|____2____|____
 ____|___-1____|____1____|____3____|
 ____ ____ ____ ____ ____ ____ ____
|-4__|-2__|_0__|_2__|_4__|_6__|_8__|
 _|_-3_|_-1_|__1_|__3_|__5_|__7_|__

Then, x(n) : â„¤ refers to a precise labelled "brick" in the brick
pattern.

Each brick encodes a real interval; specifically the interval
âŸª x(n) , n âŸ« as defined below.

âŸª_âŸ« : â„¤ Ã— â„¤ â†’ â„š Ã— â„š
âŸª k , p âŸ« = (k / 2^{p + 1}) , ((k + 2) / 2^{p + 1})

##

Therefore, an encoding of a real number is a sequence of encodings of
real intervals -- the restriction we add is that each brick x(n) is
"below" the brick x(n+1); meaning âŸª x(n+1) , n+1 âŸ« âŠ‚ âŸª x(n) , n âŸ«.

Note that there are precisely three brick below each brick.

downLeft downMid downRight : â„¤
downLeft  a = a +â„¤ a
downMid   a = succâ„¤ (downLeft a)
downRight a = succâ„¤ (downMid  a)

_below_ : â„¤ â†’ â„¤
a below b = downLeft b â‰¤â„¤ a â‰¤â„¤ downRight b

ğ•‚ : ğ“¤â‚€ Ì‡ 
ğ•‚ = Î£ x ê‰ â„¤ â†’ â„¤ , (n : â„¤) â†’ (x (succâ„¤ n)) below (x n)

The real number represented by x : ğ•‚ is defined as âŸ¦ x âŸ§ : â„.

âŸ¨_âŸ© : ğ•‚ â†’ (â„¤ â†’ â„¤)
âŸ¨ x , _ âŸ© = x

âŸ¦_âŸ§ : ğ•‚ â†’ â„
âŸ¦ x âŸ§ = â‹ƒáµ¢ âŸª âŸ¨ x âŸ© i âŸ«

## upLeft / upRight

We may also wish to go "up" the brick pattern from a specific brick.

Even-numbered bricks are covered by two bricks at the preceeding
precision-level, whereas odd-numbered bricks are covered by exactly
one.

We define the functions upLeft : â„¤ â†’ â„¤ and upRight : â„¤ â†’ â„¤, such that
when k : â„¤ is even upLeft k = predâ„¤ (upRight k) and when n is odd
upLeft k = upRight k.

upLeft upRight : â„¤ â†’ â„¤
upLeft  = {!!}
upRight = {!!}

upLeft-is-below  : (k : â„•) â†’ k below upLeft  k
upLeft-is-below  = {!!}

upRight-is-below : (k : â„•) â†’ k below upRight k
upRight-is-below = {!!}

## Replacement function

Given any Î± : ğ•‚ and i : â„¤, we can replace all precision levels n <â„¤ i
with rec upRight (i - n) Î±(i) (or upLeft) and still represent the same
real number.

replace : ğ•‚ â†’ â„¤ â†’ ğ•‚
replace (Î± , Î³Î±) i = Î» n â†’ if   n <â„¤ i
                           then rec upRight (i - n) Î±(i)
                           else Î±(n)
                   , Î» n â†’ if   n <â„¤ i
                           then rec upRight-is-below (i - n) Î³Î±(i) 
                           else Î³Î±(n)

It is the case that for all Î± : ğ•‚ and i : â„¤, âŸ¦ Î± âŸ§ â‰¡ âŸ¦ replace Î± i âŸ§.

What this means is that all information held at x(n) about locating
âŸ¦ x âŸ§ is held at x(n+1).

##

Similarly to the replacement function, we can construct ğ•‚ using just
a function â„• â†’ â„¤.

build : (Î£ x ê‰ (â„• â†’ â„¤) , (n : â„•) â†’ (x (succ n)) below (x n)) â†’ â„¤ â†’ ğ•‚
build (x , Î³x) i = Î» n â†’ if   n <â„¤ i
                         then rec upRight (i - n)  x(0)
                         else x(n - i)
                 , Î» n â†’ if   n <â„¤ i
                         then rec upRight-is-below (i - n) Î³x(i) 
                         else Î³x(n - i)
                         
##

Given any specific brick on a specific level, i.e. (k , p) : â„¤ Ã— â„¤
representing âŸª k , p âŸ«, we can define an element of the closed
interval âŸª k , p âŸ«.

ClosedInterval : â„¤ Ã— â„¤ â†’ ğ“¤â‚€ Ì‡
ClosedInterval (k , p) = Î£ (x , _) : ğ•‚ , x(p) â‰¡ k 

You can also build an element of a closed interval in a similar way

build-ci : (Î£ x ê‰ (â„• â†’ â„¤) , (n : â„•) â†’ (x (succ n)) below (x n))
         â†’ (i : â„¤) â†’ ClosedInterval (x(0) , i)
build-ci x = build x i , {!!}

## Signed-digits are isomorphic

Recall that we previously represented numbers in the closed interval
[-1,1] using signed-digit functions of type â„• â†’ ğŸ›.

â¦‰_â¦Š : (â„• â†’ ğŸ›) â†’ â„
â¦‰ Î± â¦Š = Î£áµ¢ Î± i * 2^{-i-1}

This interval is represented by the Boehm "brick" (-1 , -1) : â„• Ã— â„•.

[âˆ’1,1]-code : â„¤ Ã— â„¤
[âˆ’1,1]-code = (-1 , -1)

The location structure of the signed-digit approach is actually
isomorphic to the ternary Boehm approach.

For example, the signed digit function
 Î± â‰”     { âˆ’1            ,  O           , +1             ...} : â„• â†’ ğŸ›
follows the same location structure as
 x â‰” {-1 , downLeft x(0) , downMid x(1) , downRight x(2) ...} : â„• â†’ â„¤

ğŸ›-to-down : ğŸ› â†’ (â„¤ â†’ â„¤)
ğŸ›-to-down âˆ’1 = downLeft
ğŸ›-to-down  O = downMid
ğŸ›-to-down +1 = downRight

signed-to-boehm' : (â„• â†’ ğŸ›) â†’ (â„• â†’ â„¤)
signed-to-boehm' Î± 0 = -1
signed-to-boehm' Î± (succ n) = ğŸ›-to-down (Î± n) (signed-to-boehm' Î± n)

signed-to-boehm'-below
  : (Î± : â„• â†’ ğŸ›) â†’ (n : â„•)
  â†’ (signed-to-boehm' Î± (succ n)) below (signed-to-boehm' Î± n)
signed-to-boehm'-below Î± n = {!!} -- Easy

signed-to-boehm : (â„• â†’ ğŸ›) â†’ ClosedInterval [âˆ’1-1]-code
signed-to-boehm Î±
 = build-ci (signed-to-boehm' Î± , signed-to-boehm'-below Î±)

Therefore, it should be the case that, for all x : â„• â†’ ğŸ›
â¦‰ x â¦Š = âŸ¦ signed-to-boehm x âŸ§.

Recall that we use an interval object specification of the real
numbers ğ•€.

We already defined the following realisability map,

q : ğŸ› â†’ ğ•€
q âˆ’1 = âˆ’1
q  O =  O
q +1 = +1

ğ•¢ : (â„• â†’ ğŸ›) â†’ ğ•€
ğ•¢ = M âˆ˜ map âŸ¨_âŸ©

We also want to define the following realisability map,

ğ•£ : CompactInterval [âˆ’1,1]-code â†’ ğ•€

such that for all x : â„• â†’ ğŸ›, ğ•¢ x = ğ•£ (signed-to-boehm x).

We will do this by defining,

boehm-to-signed : CompactInterval [âˆ’1,1]-code â†’ (â„• â†’ ğŸ›)
boehm-to-signed {!!}

such that

boehm-signed-isoâ‚ : boehm-to-signed âˆ˜ signed-to-boehm â‰ƒ id
boehm-signed-isoâ‚ = {!!}

boehm-signed-isoâ‚‚ : signed-to-boehm âˆ˜ boehm-to-signed â‰ƒ id
boehm-signed-isoâ‚‚ = {!!}

Then, by setting

ğ•£ = ğ•¢ âˆ˜ boehm-to-signed,

our proof follows: we immediately get that for all x : â„• â†’ ğŸ›,

ğ•¢ x = (ğ•¢ âˆ˜ boehm-to-signed) (signed-to-boehm x),

by boehm-signed-isoâ‚.

## The key difference

The key difference between the signed digit approach and the Boehm
approach is that,
 * With signed digit, the information kept in x(n) *depends on*
                      the information in all x(i) such that i < n,
 * With Boehm codes,  the information kept in x(n) *includes*
                      the information in all x(i) such that i < n.

## Closeness function on ğ•‚

For every discrete-sequence type â„• â†’ X (where X is discrete), we have
a canonical closeness function c : (â„• â†’ X) Ã— (â„• â†’ X) â†’ â„•âˆ.

Recall that for x,y : â„• â†’ X and any Î´ : â„•,

c (x , y) â‰¼ Î¹ Î´ â‡” (x â‰ˆ y) Î´,

where c(x , y) : â„•âˆ is the value of the discrete-sequence closeness
function for x and y.

_â‰ˆ_ : {X : ğ“¤ Ì‡ } â†’ (â„• â†’ X) â†’ (â„• â†’ X) â†’ â„• â†’ ğ“¤ Ì‡
(Î± â‰ˆ Î²) n = (i : â„•) â†’ i < n â†’ Î± n â‰¡ Î² n

From the canonical closeness function on (â„• â†’ â„¤), we can define one
on ğ•‚:

c : ğ•‚ Ã— ğ•‚ â†’ â„•âˆ
c ((Î± , _) , (Î² , _)) = c (Î± âˆ˜ pos , Î² âˆ˜ pos)

Note that we only take into account positive precision-levels of
object x : ğ•‚; but, as we already said, for our purposes of encoding
real numbers, the information kept in any âŸ¨ x âŸ© (pos nâ‚) : â„¤ includes
the information kept in any âŸ¨ x âŸ© (negsucc nâ‚‚) : â„¤.

This closeness function, like that on signed-digits, gives the
closeness of *encodings* of real numbers; not the real numbers
themselves. If we wish to determine the closeness of the numbers
themselves, we can instead use the following pseudo-closenss
function (I THINK!)

pc : ğ•‚ Ã— ğ•‚ â†’ â„•âˆ 
pc ((Î± , _) , (Î² , _))
 = Î» n â†’ dec-to-ğŸš (abs (Î± (pos n) âˆ’â„¤ Î² (pos n)) â‰¤â„¤ 2)

## Predicates we wish to search

In our general regression framework, we search uniformly continuous
decidable predicates on types equipped with closeness functions.

(Recall that there is no non-trivial uniformly continuous decidable
predicate on the real numbers â„.)

When defining uniformly continuous predicates on signed-digits,
we utilised the discrete-sequence closeness function.

uc-d-predicate-on-seqs : {X : ğ“¤ Ì‡ } â†’ (p : X â†’ ğ“¥ Ì‡ ) â†’ (ğ“¤ âŠ” ğ“¥) Ì‡ 
uc-d-predicate-on-seqs {X} p
 = ((x : X) â†’ decidable (p x))
 Ã— (Î£ Î´ ê‰ â„• , (Î± Î² : â„• â†’ X) â†’ (Î± â‰ˆ Î²) Î´ â†’ p Î± â‡” p Î²)

We call the Î´ : â„• of such a predicate its 'modulus of continuity'.

So for uniformly continuous decidable predicates p on signed-digit
encodings x,y : â„• â†’ ğŸ›, with modulus of continuity Î´ : â„•, it is enough
to know that (x â‰ˆ y) Î´ to know that p(x) is logically equivalent
to p(y).

(Reword â†“)
But! With Boehm codes ğ•‚, all the information is kept in the most recent
code. So if an "equivalent" predicate should only need to satisfy the
following.

special-predicate : (p : ğ•‚ â†’ ğ“¤ Ì‡ ) â†’ ğ“¤ Ì‡
special-predicate p
 = ((x : ğ•‚) â†’ decidable (p x))
 Ã— (Î£ Î´ ê‰ â„• , (Î± Î² : ğ•‚) â†’ âŸ¨ Î± âŸ© (pos Î´) â‰¡ âŸ¨ Î² âŸ© (pos Î´) â†’ p Î± â‡” p Î²)


Relationships:
 * c (Î± , Î²) â‰¼ Î´                 â†’ pc (Î± , Î²) â‰¼ Î´
 * c (Î± , Î²) â‰¼ (succ Î´)          â†’ âŸ¨ Î± âŸ© (pos Î´) â‰¡ âŸ¨ Î² âŸ© (pos Î´)
 * âŸ¨ Î± âŸ© (pos Î´) â‰¡ âŸ¨ Î² âŸ© (pos Î´) â†’ pc (Î± , Î²) â‰¼ Î´ ?
